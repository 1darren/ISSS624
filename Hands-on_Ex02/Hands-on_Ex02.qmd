---
title: "Hands-on Exercise 2: Spatial Weights & Spatial Autocorrelation"
editor: visual
---

On this page, I address Hands-On Exercise for Chapter 02:

- [**Spatial Weights and Applications**](#import-hunan-shapefile-datasets)
- [**Global Measures of Spatial Autocorrelation**](#global-measures-of-spatial-autocorrelation)
- [**Local Measures of Spatial Autocorrelation**](#local-measures-of-spatial-autocorrelation)


# 1. Spatial Weights & Applications
- Creating `nb` matrix using `QUEEN`/`ROOK` Contiguity
- Creating `wm_d62` weight matrix with fixed distance
    - Fixed distance found by creating `nb` matrix using knn=1
- Creating `rwsm_q` with `style="W"`, row-standardised weight matrix
    - this creates `Spatial lag with row-standardized weights`
    - also creates `Spatial Window Average`
- Creating `rwsm_ids` with `style="B"`, binary weights, 
    - this creates `Spatial lag as a sum of neighbouring values`
    - also creates `Spatial Window Sum`

## 1.2 Import `Hunan` Shapefile datasets

### 1.2.1 Geospatial Data Sets

-   `/data/geospatial/Hunan.###`: This is a geospatial data set in ESRI shapefile format.

### 1.2.2 Aspatial Data Sets

-   `/data/aspatial/Hunan_2012.csv`: This csv file contains selected Hunan's local development indicators in 2012.

## 1.3 Import packages & files

- `hunan`: `sf` data.frame
- `hunan2012`: `tbl_df` data.frame

```{r}
#| code-fold: true
#| code-summary: "show code"
print("Importing packages...")
pacman::p_load(sf, spdep, tmap, tidyverse, knitr)

print("\nLoading dataset packages...")
hunan <- st_read(dsn = "data/geospatial", 
                 layer = "Hunan")
hunan2012 <- read_csv("data/aspatial/Hunan_2012.csv")
```
-  Left join `hunan2012` to `hunan`, select only specific columns

```{r}
#| code-fold: true
#| code-summary: "show code"
hunan <- left_join(hunan,hunan2012)%>%
  select(1:4, 7, 15)
print("Previewing first 5 rows of joined, filtered hunan df")
kable(head(hunan, 5))
```

## 1.4 Visualisation with qtm next to basemap

```{r}
#| code-fold: true
#| code-summary: "show code"
basemap <- tm_shape(hunan) +
  tm_polygons() +
  tm_text("NAME_3", size=0.5) +
  tm_layout(main.title = "basemap of Hunan")

gdppc <- qtm(hunan, "GDPPC")  +
  tm_layout(main.title = "GDPPC Quintile Map")
tmap_arrange(basemap, gdppc, asp=1, ncol=2)
```

## 1.5 Contiguity Spatial Weights

-   There are 2 types of contiguity, based on chess pieces
    -   `QUEEN` two regions are contiguous if they share a vertex;
    -   `ROOK` two regions are contiguous if they share an edge;
-   Literature suggests they are mostly similar, but `QUEEN` is more robust at capturing neighbouring/contiguity more consistently

#### 1.5.1 `QUEEN` Contiguity Neighbours

```{r}
#| code-fold: true
#| code-summary: "show code"
wm_q <- poly2nb(hunan, queen=TRUE)
summary(wm_q)
```

Identifying all neighbours of most connected region:

```{r}
#| code-fold: true
#| code-summary: "show code"
cat("Most connected region, 85:", hunan$County[85], "\nNeighbours:\n\t")
wm_q[[85]]

cat("\nPreviewing neighbours:\n\n>> ID\t|  Name \t| GDPPC  \t|  Neighbours:")

for (value in wm_q[[85]]){
  cat("\n>> ", value, "\t|", hunan$County[value], "  \t|", hunan$GDPPC[value], "  \t|", wm_q[[value]])
  }
```


-   Print adjacency matrix with `str` (warning: long!)

::: {.callout-caution collapse="true"}
## Expand to see adjacency weight matrix

```{r}
str(wm_q)
```
:::

#### 1.5.2 `ROOK` Contiguity Neighbours

```{r}
#| code-fold: true
#| code-summary: "show code"
wm_r <- poly2nb(hunan, queen=FALSE)
summary(wm_r)
```

-   Which of Taoyuan's neighbours is now missing?

```{r}
setdiff(wm_q[[85]], wm_r[[85]])
hunan$County[[57]]
```
- This is the difference between `ROOK` & `QUEEN`: Taoyuan & Nan share only a vertex, no edges
![Alt text](taoyuan-nan.jpg)

### 1.5.3 Exploring Contiguity Weights

-   Get `latitude`, `longtiude` by
    -   `map_dbl` retrieving double-precision datatype via map function on `geometry` column of `hunan`
    -   use `st_centroid` to find centroid of each row
    -   indexing via \[\[1\]\], \[\[2\] for long,lat of centroid
    -   retrieving a vector of regions
-   `cbind` combines separate vectors back into single dataframe (`coords`)with two columns

```{r}
#| code-fold: true
#| code-summary: "show code"
longitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])
latitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])
coords <- cbind(longitude, latitude)
cat("Printing first 6 rows of `coords`:\n")
head(coords)
```

-   now using centroid vertices, we plot:
    - plot QUEEN-contiguity map
    - plot ROOK-contiguity map
    - plot differences (i.e. ROOK overlapping Queen)

```{r}
#| code-fold: true
#| code-summary: "show code"
par(mfrow=c(1,3), lty = 2, lwd = 2)
plot(hunan$geometry, border="lightgrey")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red", main="Queen Contiguity")
title("QUEEN Contiguity")
box()
plot(hunan$geometry, border="lightgrey")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "blue", main="Rook Contiguity")
title("ROOK Contiguity")
box()
plot(hunan$geometry, border="lightgrey")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red", main="Queen Contiguity")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "blue", main="Rook Contiguity")
title("Differences:")
box()

```

------------------------------------------------------------------------

## 1.6 Distance-based neighbours

### 1.6.1 Identifying max inter-neighbour distance

-   `k1` created by parsing
    -   `knearneigh` returns matrix of k (default=1) nearest neighbours's index based on `coords`, apparently in `knn` object
    -   `knn2nb` converts k-nearest-neighbours to neighbours-list in `nb` class
-   `unlist` unbinds list structure of output into vector
    -   `nbdists` takes in `nb` neighbours list and returns euclidean distances between neighbours in same structure
-   all this searches the greatest neighbour distance (max 61.79 below) to ensure each region has at least one neighbour

```{r}
#| code-fold: true
#| code-summary: "show code"

# coords <- coordinates(hunan) #following previous steps
k1 <- knn2nb(knearneigh(coords))
k1dists <- unlist(nbdists(k1, coords, longlat = TRUE))
cat("Printing summary stats for k-1 distances\n")
summary(k1dists)

```

### 1.6.2 Creating fixed distance weight matrix

-   `dnearneigh` returns list of vectors of regions satisfying distance criteria (eg within max neighbour distance)

```{r}
#| code-fold: true
#| code-summary: "show code"
wm_d62 <- dnearneigh(coords, 0, 62, longlat = TRUE)
cat("Printing details of distance weight matrix\n")
wm_d62

cat("\nInspecting first six rows of [wm_d62] obj \n")
cat(str(head(wm_d62, n=6)))

cat("\n^ Note how 6th row only has one neighbour, i.e. region 69")

```

::: callout-note
## **Quiz**: What is the meaning of "Average number of links: 3.681818" shown above?

-   Each region has 3.68 links on average, i.e. (total number of links) / (total number of regions)
:::

-   Alternative structure (warning: long!)
    -   this uses `table` to combine the column name from `hunan$Country` with `wm_d62`
    -   `card` apparently looks at the length of the neighbour list and prints 1 if yes, 0 if no (i.e. Anhua has `1` neighobur, Anren has `4`)
- Warning, long table!

::: {.callout-caution collapse="true"}
## (Warning, long!) Expand to read adjacency weight matrix

```{r}
table(hunan$County, card(wm_d62))
```
:::

### 1.6.2x Unfinished Disjoint subgraph plot

- this section was tucked right above [8.6.2.1](https://r4gdsa.netlify.app/chap08#plotting-fixed-distance-weight-matrix) without explanation
-   `n.comp.nb()` finds the number of disjoint connected subgraphs [\[see source\]](https://r-spatial.github.io/spdep/reference/compon.html)

```{r}
#| code-fold: true
#| code-summary: "show code"
n_comp <- n.comp.nb(wm_d62)
cat("Number of disjoint subgraphs:", n_comp$nc)
cat("\nTable of disjoint subgraphs by region:\n")
table(n_comp$comp.id)
cat("^ i.e. 88 regions all report 1 distjoint subgraph, i.e. no region is disjoint")

```

#### 1.6.2.1 Plotting fixed distance weight matrix

-   Plot background of `hunan$Geometry`
-   Plot points of centroids in `coords`, connected by black lines
-   Plot k=1-nearest-neighbours (i.e. show nearest neighbours as in `k1`) in red lines on top; 

```{r}
#| code-fold: true
#| code-summary: "show code"
plot(hunan$geometry, border="lightgrey")
plot(wm_d62, coords, add=TRUE)
plot(k1, coords, add=TRUE, col="red", length=0.08)

title("Comparing fixed-distance neighbours (black)\nvs 1st-nearest-neighbours (red)")
box()
```

-   Side-by-side comparison:

```{r}
#| code-fold: true
#| code-summary: "show code"
par(mfrow=c(1,2))
plot(hunan$geometry, border="lightgrey")
plot(k1, coords, add=TRUE, col="red", length=0.08, main="1st nearest neighbours")
title("1st Nearest Neighbours")
box()
plot(hunan$geometry, border="lightgrey")
plot(wm_d62, coords, add=TRUE, pch = 19, cex = 0.6, main="Distance link")
title("Distance-Based Neighbours")
box()
```

### 1.6.3 Exploring Contiguity Weights

-   Now calculating 6 nearest neighbours via `knn` algorithm

```{r}
#| code-fold: true
#| code-summary: "show code"

knn6 <- knn2nb(knearneigh(coords, k=6))
cat("Printing details of knn neighbour matrix, k=6 \n")
knn6

cat("\nInspecting first six rows of [knn6] obj \n")
cat(str(head(knn6, n=6)))
cat("\n^ Note how every row now has 6 neighbours exactly.")
```

-   Here's what it looks like instead:

```{r}
#| code-fold: true
#| code-summary: "show code"
#| 
par(mfrow=c(1,2))
plot(hunan$geometry, border="lightgrey", main="1st Nearest Neighbours")
plot(k1, coords, pch = 19, cex = 0.6, add=TRUE, col="red", length=0.08)
box()


plot(hunan$geometry, border="lightgrey", main ="6st Nearest Neighbours")
plot(knn6, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
box()

```

## 1.7 Using Inversed Distance to plot neighbour

-   Starting with `wm_q` for queen contiguity, `coords` for centroids
    -   `nbdists` takes in `nb` neighbours list and returns euclidean distances between neighbours in same structure
    -   `longlat` uses [Great Circle distances](https://en.wikipedia.org/wiki/Great-circle_distance) i.e. distance on a round earth instead of flat map
-   `lapply` `function(x)` applies inverse (1/x) to all output distances

```{r}
#| code-fold: true
#| code-summary: "show code"
dist <- nbdists(wm_q, coords, longlat = TRUE)
ids <- lapply(dist, function(x) 1/(x))
cat("\nInspecting first five rows of [ids] obj \n\n")
head(ids, 5)
```

### 1.7.1 Creating row-standardised weight matrix

-   `style "W"` gives equal weight to each neighbour (e.g. 0.125 for 8 neighbours, below)

```{r}
#| code-fold: true
#| code-summary: "show code"
rswm_q <- nb2listw(wm_q, style="W", zero.policy = TRUE)
rswm_q

cat("\nInspecting weights for region 10, with 8 neighbours: \n")
rswm_q$weights[10]
```

-   `style "B"` performs standardisation based on row distance

```{r}
#| code-fold: true
#| code-summary: "show code"
rswm_ids <- nb2listw(wm_q, glist=ids, style="B", zero.policy=TRUE)
rswm_ids

cat("\nPrinting summary stats for row-standardised weights matrix \n")
summary(unlist(rswm_ids$weights))

cat("\nInspecting weights for region 10, with 8 neighbours: \n")
rswm_ids$weights[10]
```

## 1.8 Making use of spatial weight matrix

### 1.8.1 Spatial lag with row-standardized weights

::: callout-note
## **Quiz**: Can you see the meaning of Spatial lag with row-standardized weights now?

-   **Spatial lag** as a concept describes how spatially-neighbouring regions affect each other
    -   Use of row-standardised weights assigns weights to neighbours based on proximity (i.e. nearer neighbour affects more)
    -   It's one way to calculate spatial lag, using distance to weight importance of neighbours
:::

-   Calculating `spatially lagged GDPPC` values

```{r}
#| code-fold: true
#| code-summary: "show code"
GDPPC.lag <- lag.listw(rswm_q, hunan$GDPPC)


cat("\nInspecting first 5 values for `Average Neighbour GDPPC`: \n")
head(GDPPC.lag, 5)
```

-   Creating `lag.res` dataframe with regionname and `lag GDPPC` value
    -   `NAME_3` column created for ease of left-join with `hunan`
-   `left_join` to create table of rows of region-neighbour-lag GDPPC-geometry

```{r}
#| code-fold: true
#| code-summary: "show code"
lag.list <- list(hunan$NAME_3, lag.listw(rswm_q, hunan$GDPPC))
lag.res <- as.data.frame(lag.list)
colnames(lag.res) <- c("NAME_3", "lag GDPPC")

cat("\nInspecting first row for `lag.res` : \n")
cat(str(lag.res[1]))

cat("\nShowing first 6 rows for joined `hunan +lag.res` : \n")
hunan <- left_join(hunan,lag.res)
head(hunan)

```

-   Visual comparison of regional GDPPC and spatial lag GDPPC
    -   Adjusted colour breaks to use comparable scale -- MAPS CAN LIE! as Prof Kam says

```{r}
#| code-fold: true
#| code-summary: "show code"
gdppc <- qtm(hunan, "GDPPC") +
  tm_layout(main.title = "GDPPC", main.title.position = "right")
lag_gdppc <- qtm(hunan, "lag GDPPC",
                  fill.style="fixed",fill.breaks=c(0,20000,40000,60000,80000,100000)) +
  tm_layout(main.title = "lag GDPPC", main.title.position = "right")
tmap_arrange(gdppc, lag_gdppc, asp=1, ncol=2)


```

### 1.8.2 spatial lag as a sum of neighbouring values

-   Using binary weights (0/1) to create `spatial lag` as a simple unweighted sum

    -   use of `nb2listw`, `style = "B"` from before:

    ```{r}
    #| code-fold: true
    #| code-summary: "show code"
    b_weights <- lapply(wm_q, function(x) 0*x + 1)
    b_weights2 <- nb2listw(wm_q, 
                           glist = b_weights, 
                           style = "B")
    b_weights2
    ```

```{r}
#| code-fold: true
#| code-summary: "show code"
lag_sum <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))
lag.res <- as.data.frame(lag_sum)
colnames(lag.res) <- c("NAME_3", "lag_sum GDPPC")

cat("Printing first five rows of lag_sum\n")
for (i in 1:5) {
  print(str(c(i, lag_sum[[1]][[i]], lag_sum[[2]][[i]])))
}

hunan <- left_join(hunan, lag.res)
gdppc <- qtm(hunan, "GDPPC",
             fill.style="fixed", fill.breaks=c(0,20000,40000,60000,80000,100000, 200000, 300000, 400000, 500000)) +
  tm_layout(main.title = "GDPPC", main.title.position = "right")

lag_sum_gdppc <- qtm(hunan, "lag_sum GDPPC",
                     fill.style="fixed", fill.breaks=c(0,20000,40000,60000,80000,100000, 200000, 300000, 400000, 500000)
                     ) +
  tm_layout(main.title = "lag_sum GDPPC", main.title.position = "right")
tmap_arrange(gdppc, lag_sum_gdppc, asp=1, ncol=2)

```

::: callout-note
## **Quiz**: Can you understand the meaning of Spatial lag as a sum of neighboring values now?

-   Unlike before, here the spatial lag GDPP is calculated simply as a sum of neighbouring regions; this looks less accurate
    -   more neighbours, more spatial lag; leads to huge disparity if one region has 8 neighbours and one region has only 1
    -   note that often the scale is up to 10x the GDPPC; harder to compare values
:::

### 1.8.3 Spatial window average

- `Spatial Window Average` is row-standardised weights + self ("diagonal element")
    - area[1] now has an additional 'neighbour', itself, for use in calculating row-standardised weights

```{r}
#| code-fold: true
#| code-summary: "show code"
wm_qs <- include.self(wm_q)
wm_qs <- nb2listw(wm_qs)
wm_qs
```
- Now we create lag variable, as before;
    - `lag.listw` calculates lag value
    - `as.data.frame()` and `list()` converts into dataframe
    - `colnames` renames columns to `NAME_3`, `lag_window_avg GDPPC` for ease of left joining
- Maybe I should've used `kable()` to display my values instead of using `cat` to print:



```{r}
#| code-fold: true
#| code-summary: "show code"
lag_w_avg_gpdpc <- lag.listw(wm_qs, 
                             hunan$GDPPC)
lag.list.wm_qs <- list(hunan$NAME_3, lag.listw(wm_qs, hunan$GDPPC))
lag_wm_qs.res <- as.data.frame(lag.list.wm_qs)
colnames(lag_wm_qs.res) <- c("NAME_3", "lag_window_avg GDPPC")
hunan <- left_join(hunan, lag_wm_qs.res)

cat("Displaying table of modified values:")
hunan %>%
  select("County", 
         "lag GDPPC", 
         "lag_sum GDPPC",
         "lag_window_avg GDPPC") %>%
  kable()
```

- Now comparing `lag_gdppc` and `w_ave_gdppc` on the same colour scale
```{r}
#| code-fold: true
#| code-summary: "show code"

lag_gdppc <- qtm(hunan, "lag GDPPC",
                  fill.style="fixed",fill.breaks=c(10000,20000,30000,40000,50000,60000),
                 legend.text.size = 0.5,legend.title.size = 0.5
                 ) +
  tm_layout(main.title = "Lag GDPPC", main.title.position = "right")

w_avg_gdppc <- qtm(hunan, "lag_window_avg GDPPC",
                   fill.style="fixed", fill.breaks=c(10000,20000,30000,40000,50000,60000),
                   legend.text.size = 0.5,legend.title.size = 0.5
                   ) +
  tm_layout(main.title = "lag_window_avg GDPPC", main.title.position = "right")
tmap_arrange(lag_gdppc, w_avg_gdppc, asp=1, ncol=2)


```

### 1.8.4 Spatial Window Sum

- Simple `sum of neighbouring values` including self/diagonal value
    - `lapply` to create matrix of ones in shape of `nb` structure
    - use of `nb2listw` to assign a weights list object according to `nb` shape
- use of `lag.listw()` to create lag variable for each region

```{r}
#| code-fold: true
#| code-summary: "show code"
wm_qs <- include.self(wm_q) # Run above 
b_weights <- lapply(wm_qs, function(x) 0*x + 1)
b_weights2 <- nb2listw(wm_qs, 
                       glist = b_weights, 
                       style = "B")
w_sum_gdppc <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))

cat("Printing first five rows of w_sum_gdppc\n")
for (i in 1:5) {
  print(str(c(i, w_sum_gdppc[[1]][[i]], w_sum_gdppc[[2]][[i]])))
}
```


- Then, just as before, convert using `as.data.frame()`, rename with `col_names` and `left_join` into huge `hunan` "sf" data.frame

```{r}
#| code-fold: true
#| code-summary: "show code"
w_sum_gdppc.res <- as.data.frame(w_sum_gdppc)
colnames(w_sum_gdppc.res) <- c("NAME_3", "w_sum GDPPC")
hunan <- left_join(hunan, w_sum_gdppc.res)

hunan %>%
  select("County", 
         "GDPPC", 
         "lag GDPPC", 
         "lag_window_avg GDPPC",
         "lag_sum GDPPC",
         "w_sum GDPPC") %>%
  kable()

```



- Side-by-side comparison plot with `lag_sum GDPPC`

```{r}
#| code-fold: true
#| code-summary: "show code"
lag_sum_gdppc <- qtm(hunan, "lag_sum GDPPC",
                     fill.style="fixed", fill.breaks=c(0,100000, 200000, 300000, 400000, 500000),
                     legend.text.size = 0.5,legend.title.size = 0.5
                     ) +
  tm_layout(main.title = "lag_sum GDPPC", main.title.position = "right")
w_sum_gdppc <- qtm(hunan, "w_sum GDPPC",
                   fill.style="fixed", fill.breaks=c(0,100000, 200000, 300000, 400000, 500000),
                  legend.text.size = 0.5,legend.title.size = 0.5
                   ) +
  tm_layout(main.title = "w_sum GDPPC", main.title.position = "right")
tmap_arrange(lag_sum_gdppc, w_sum_gdppc, asp=1, ncol=2)
```


# 2. Global Measures of Spatial Autocorrelation
- Visualizing difference between `equal interval` and `equal quantile` plots
- Use of `Moran's I` test to test global spatial autocorrelation
    - Important to note, we are calculating **Global** Moran's I, vs Local Moran's I, later
    - Use of `Monte Carlo Moran's I` simulations
- Use of `Geary's C` test to test global spatial autocorrelation
    - Use of `Monte Carlo Geary's C` simulations
- Drawing Spatial Correlogram for both `Moran's I` and `Geary's C`


## 2.1 Analytical Question
- Identify if development is equally distributed geographically in Hunan province
- If **NO**, then ask: Is there signs of spatial clustering?
- If **YES**, then ask: Where is the spatial clustering?

## 2.2 Import Datasets
## 2.3 Import Packages 

- Actually, the same datasets are used from above; see [Section 1.2](#import-hunan-shapefile-datasets)
    -   `/data/geospatial/Hunan.###`: This is a geospatial data set in ESRI shapefile format.
    -   `/data/geospatial/Hunan.###`: This is a geospatial data set in ESRI shapefile format.
- Similarly, the same packages are used, see [Section 1.3](#import-packages-files)
    - `sf`, `spdep`, `tmap`, `tidyverse`


```{r}
# import can be ignored, loaded from before
# pacman::p_load(sf, spdep, tmap, tidyverse, knitr)

# We run here to reload hunan dataframe, remove spatial lag columns added in earlier
hunan <- st_read(dsn = "data/geospatial", 
                 layer = "Hunan")
hunan2012 <- read_csv("data/aspatial/Hunan_2012.csv")
hunan <- left_join(hunan,hunan2012) %>%
  select(1:4, 7, 15)
kable(head(hunan, 5))
```

- Now we create a basemap and chloropleth to look at `GDPPC` values for 2023
- Note the difference in scales!

```{r}
#| code-fold: true
#| code-summary: "show code"
equal <- tm_shape(hunan) +
  tm_fill("GDPPC",
          n = 5,
          style = "equal") +
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "Equal interval classification", main.title.position = "right")

quantile <- tm_shape(hunan) +
  tm_fill("GDPPC",
          n = 5,
          style = "quantile") +
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "Equal quantile classification", main.title.position = "right")

tmap_arrange(equal, 
             quantile, 
             asp=1, 
             ncol=2)
```


## 2.4 Calculating Global Spatial Autocorrelation


1. Create QUEEN contiguity weight matrix as in [Section 1.5](#contiguity-spatial-weights), *Contiguity Spatial Weights*
2. Create row-standardised weight matrix as in[Section 1.7.1](#creating-row-standardised-weight-matrix), *Creating row-standardised weight matrix*
    - use of `style="W"` for equal weights here for example, but `Style="B"` more robust

```{r}
#| code-fold: true
#| code-summary: "show code"
wm_q <- poly2nb(hunan, 
                queen=TRUE)
# summary(wm_q)
rswm_q <- nb2listw(wm_q, 
                   style="W", 
                   zero.policy = TRUE)
rswm_q

```

## 2.4 "M": Moran's I test 
- `Moran's I` evaluates spatial autocorrelation and returns whether pattern is clustered, dispersed, or random (i.e. no autocorrelation)

```{r}
#| code-fold: true
#| code-summary: "show code"
moran.test(hunan$GDPPC, 
           listw=rswm_q, 
           zero.policy = TRUE, 
           na.action=na.omit)
```

::: callout-note
## **Quiz**: What statistical conclusion can you draw from the output above?

-  **Moran's I Statistic:** of ~0.3 indicates weak spatial correlation
    - (+) means similar values are closer (e.g. high with high); (-) means dissimilar values cluster (e.g. high with low)
    - Closer to 0 means random, closer to 1 or -1 indicates strong correlation
    - Expected value is -1/(N-1), i.e. -1/87 here, which is close enough to 0 for estimation
-  **alternative: greater:** Suggests that the alternative hypothesis is true, that GDPPC value has is spatially correlated (e.g. neighbouring regions affect value)
    - null hypothesis is that the GDPPC is randomly distributed in space
-  **p-Value:** of magnitude 1e-06 suggests confidence/statistical significance of result
    - p value < 0.05 suggests result is not due to random chance
:::


### 2.4.1 "M": Monte Carlo Moran's I test 
- Not sure where the is necessary, but [R documentation](https://www.rdocumentation.org/packages/spdep/versions/1.2-8/topics/moran.test) suggests also using the Monte Carlo version
- `Moran's I` evaluates spatial autocorrelation and returns whether pattern is clustered, dispersed, or random (i.e. no autocorrelation)
    - even using a different seed from Prof, values are similar 

```{r}
#| code-fold: true
#| code-summary: "show code"
set.seed(42)
bperm= moran.mc(hunan$GDPPC, 
                listw=rswm_q, 
                nsim=999, 
                zero.policy = TRUE, 
                na.action=na.omit)
bperm

```
::: callout-note
## **Quiz**: What statistical conclusion can you draw from the output above?

-  **Moran's I Statistic:** of 0.30075 indicates weak spatial correlation, as before; 
    -  **alternative: greater:** Suggests that the alternative hypothesis is true, that GDPPC value has is spatially correlated (e.g. neighbouring regions affect value)
    -  **p-Value:** of 0.001  suggests confidence/statistical significance of result; 0.001 probability of observing results like that
    - **observed rank** according to documentations suggests the observed statistic is ranked 1000th of 1000 simulations, but I am not sure of what this means.
    
:::



## 2.4.4.2 Visualising Monte Carlo Moran's I test 
- Extracting key statistics from `$res` column

```{r}
#| code-fold: true
#| code-summary: "show code"
cat("Printing values from simulation:")
cat("\n>> mean\t: ", mean(bperm$res[1:999]))
cat("\n>> var\t: ", var(bperm$res[1:999]))
cat("\n>> summary:\n")
summary(bperm$res[1:999])

```
- plotting `res` column in histogram:
```{r}
#| code-fold: true
#| code-summary: "show code"
hist(bperm$res, 
     freq=TRUE, 
     breaks=20, 
     xlab="Simulated Moran's I",
     main="Histogram of Moran's I statistics, 1000 simulations")
abline(v=0, 
       col="red") 

```

::: callout-note
## **Quiz**: What statistical observation can you draw from the output above?

-  Monte Carlo results in normal distribution; most values are close to zero or slightly negative -- close to expected value
    - most values within 0.2; relatively weak spatial correlation
- **observed rank** The Moran's I statistic of 0.30075 is ranked 1000/1000 simulations, and the highest statistic obtained
    
:::



::: callout-note
## **Challenge**: Instead of using Base Graph to plot the values, plot the values by using ggplot2 package.

- Doesn't generate the exact same histogram, but close enough
- Not sure why `breaks = 20` for `geom_histogram` doesn't work right, have to manually compute `data_binwidth` instead
:::

```{r}
#| code-fold: true
#| code-summary: "show code"
library(ggplot2)

# Create a sample dataset
set.seed(123)
data <- as.data.frame(bperm$res)
data_binwidth <- (max(bperm$res) - min(bperm$res)) / 20

ggplot(data, aes(x = bperm$res)) +
  geom_histogram(binwidth = data_binwidth, fill = "grey", color = "black", alpha = 0.7) +
  labs(title = "ggplot2 Histogram Counter-Example", x = "Simulated Moran's I", y = "Frequency") + 
  geom_vline(xintercept = 0, color = "red", linetype = "dashed", size = 1)
  
```


## 2.4.5  Geary's C Statistics
- `Geary's C` evaluates spatial autocorrelation at global level;
    - Geary's C is inversely related to Moran's I; 
    - Geary's C uses sum of squared distances, less sensitive to linear associations
    - Moran's I uses standardized spatial covariance

```{r}
#| code-fold: true
#| code-summary: "show code"
geary.test(hunan$GDPPC, listw=rswm_q)

```
::: callout-note
## **Quiz**: What statistical conclusion can you draw from the output above?

-  **Geary's C Statistic:** of 0.69 suggests spatial correlation, i.e. GDPPC is related to neighbours
    - Geary's c < 1 [indicates positive spatial autocorrelation](https://www.nku.edu/~longa/geomed/ppa/doc/globals/Globals.htm#:~:text=A%20value%20of%20Geary's%20c,points%20to%20negative%20spatial%20autocorrelation.), while >1 suggests spatial dispersion (negative auto-correlation) 
    -  **alternative hypothesis: Expectation greater than statistic:** Suggests that the alternative hypothesis is true, that GDPPC value has is positively spatially correlated (e.g. neighbouring regions affect value)
    -  **p-Value:** of 0.0001526 suggests confidence/statistical significance of result; very very low probability that result obtained is due to pure chance

:::

- corresponding Monte Carlo permutation test for Geary's C; even with a different seed, the values are similar

```{r}
#| code-fold: true
#| code-summary: "show code"
set.seed(42)
bperm=geary.mc(hunan$GDPPC, 
               listw=rswm_q, 
               nsim=999)
bperm

```

::: callout-note
## **Quiz**: What statistical conclusion  can you draw from the output above?

- **observed rank** The Geary's C statistic of 0.69072 is ranked 2/1000 simulations, and the second-lowest; i.e. most values are higher.
- **p-value** of 0.002 is still very small, results unlikely to be due to randomness; **alternative hypothesis: greater** suggests there exists positive auto-correlation
    
:::


## 2.4.5.3 Visualising Monte Carlo Geary's C test 
- Extracting key statistics from `$res` column

```{r}
#| code-fold: true
#| code-summary: "show code"
cat("Printing values from Geary's C simulation:")
cat("\n>> mean\t: ", mean(bperm$res[1:999]))
cat("\n>> var\t: ", var(bperm$res[1:999]))
cat("\n>> summary:\n")
summary(bperm$res[1:999])

```
- plotting `res` column in histogram:
```{r}
#| code-fold: true
#| code-summary: "show code"
hist(bperm$res, 
     freq=TRUE, 
     breaks=20, 
     xlab="Simulated Geary's c",
     main="Histogram of Geary's c statistics, 1000 simulations")
abline(v=1, 
       col="red") 

```

::: callout-note
## **Quiz**: What statistical conclusion  can you draw from the output above?

- **observed rank** The Geary's C statistic of 0.69072 is ranked 2/1000 simulations, and the second-lowest; i.e. most values are higher.
    - as before, Monte Carlo simulations seem to generate normal distribution
    - positive spatial correlation exists but not strong; mostly near expected value 1.0 
    
:::


## 2.5 Spatial Correlogram
### 2.5.1 Moran's I Correlogram

```{r}
#| code-fold: true
#| code-summary: "show code"
MI_corr <- sp.correlogram(wm_q, 
                          hunan$GDPPC, 
                          order=6, 
                          method="I", 
                          style="W")
print(MI_corr)
plot(MI_corr)

```

::: callout-note
## **Quiz**: What statistical conclusion can you draw from the plot/output above?

- **Correlogram** At smaller lags (i.e. smaller distance away) there is positive spatial auto-correlation, fading away to randomness/no autocorrelation at intermediate lags, and negative at higher (5-6) lags
- Observing **printout**, lags at 3 and 4 are not strongly statistically significant, best results at lags 1, 2, 5.
    
:::


### 2.5.2 Geary's C Correlogram

```{r}
#| code-fold: true
#| code-summary: "show code"
GC_corr <- sp.correlogram(wm_q, 
                          hunan$GDPPC, 
                          order=6, 
                          method="C", 
                          style="W")
print(GC_corr)
plot(GC_corr)


```

::: callout-note
## **Quiz**: What statistical conclusion can you draw from the plot/output above?

- **Correlogram** At smaller lags (i.e. smaller distance away) there is positive spatial auto-correlation, fading away to randomness/no autocorrelation at intermediate lags, and negative at higher (5-6) lags
- Observing **printout**, lags at 3, 4, 6 are not strongly statistically significant, best results at lags 1, 2, 5.
    - Probably because few regions are 6-regions away; results probably most accurate for 1- or 2-regions away
    
:::



# 3. Local Measures of Spatial Autocorrelation
- Calculating `Local Moran's I` for each region
- Creating LISA Clustermap
- Creating Hotspot & Coldspot
- Calculating Getis and Ord's Gi* values using fixed and adaptive distances

## 3.1 Analytical Question
- Identify if development is equally distributed geographically in Hunan province
- If **NO**, then ask: Is there signs of spatial clustering?
- If **YES**, then ask: Where is the spatial clustering?


## 3.2 Import Datasets
## 3.3 Import Packages 

- Actually, the same datasets are used from above; see [Section 1.2](#import-hunan-shapefile-datasets) and even [Section 2.1]
    -   `/data/geospatial/Hunan.###`: This is a geospatial data set in ESRI shapefile format.
    -   `/data/geospatial/Hunan.###`: This is a geospatial data set in ESRI shapefile format.
- Similarly, the same packages are used, see [Section 1.3](#import-packages-files)
    - `sf`, `spdep`, `tmap`, `tidyverse`


```{r}
# import can be ignored, loaded from before
# pacman::p_load(sf, spdep, tmap, tidyverse, knitr)

# We run here to reload hunan dataframe, remove spatial lag columns added in earlier
hunan <- st_read(dsn = "data/geospatial", 
                 layer = "Hunan")
hunan2012 <- read_csv("data/aspatial/Hunan_2012.csv")
hunan <- left_join(hunan,hunan2012) %>%
  select(1:4, 7, 15)
kable(head(hunan, 5))
```

(some repeated content truncated)

## 3.6 Cluster & Outlier Analysis
- use of `LISA` (Local Indicators of Spatial Association) to detect clusters/outliers from Hunan GDPPC

### 3.6.1 Local Moran's I
- (Global) Moran's I is performed over the entire dataset, looking for pattern across all the datapoints considered
    - Local Moran's I checks each individual datapoint for spatial correlation to detect individual clusters
- `localmoran()` thus identifies a Local Moran's I score for each of 88 regions

```{r}
#| code-fold: true
#| code-summary: "show code"
fips <- order(hunan$County)
localMI <- localmoran(hunan$GDPPC, rswm_q)
print("Printing first 6 rows of `localMI`\n")
head(localMI)
```

-   Print coefficient matrix of localMoran (warning: long!)

::: {.callout-caution collapse="true"}
## Warning: LONG! Using `str()` to print LocalMoran output Table

```{r}
printCoefmat(data.frame(
  localMI[fips,], 
  row.names=hunan$County[fips]),
  check.names=FALSE)
```
:::


### 3.6.1.1 Mapping Local Moran's I
- first we append the output coefficient matrix from `localMI` to hunan before mapping

```{r}
#| code-fold: true
#| code-summary: "show code"
hunan.localMI <- cbind(hunan,localMI) %>%
  rename(Pr.Ii = Pr.z....E.Ii..)

max_row <- hunan.localMI[which.max(hunan.localMI$Ii), ]
print(paste0("The region of deepest blue is: ", max_row$County))


local_moran_stats <- tm_shape(hunan.localMI) +
  tm_fill(col = "Ii", 
          style = "pretty",
          palette = "RdBu",
          title = "Local Moran Statistics") +
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "Local Moran Statistics")

local_moran_p <- tm_shape(hunan.localMI) +
  tm_fill(col = "Pr.Ii", 
          breaks=c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),
          palette="-Greens", 
          title = "local Moran's I p-values") +
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "Local Moran's I p-values")

tmap_arrange(local_moran_stats, 
             local_moran_p, 
             asp=1, 
             ncol=2)
```
- Overall, looks like generally weakly positive spatial autocorrelation
- Region of darkest blue (i.e. most influenced by neighbours) is Changsha, 4.9022 (or Wangcheng, 4.4220)
    - confidently so, as p-values of regions are extremely low


## 3.7 LISA Cluster Maps
- plot significant locations of spatial autocorrelation

### 3.7.1 Moran scatterplot
- scatterplot of spatially lag GDPPC (y-axis) against region's GDPPC (x-axis)
- top-right quadrant show regions of high GDPPC and high GDPPC-neighbours

```{r}
#| code-fold: true
#| code-summary: "show code"
nci <- moran.plot(hunan$GDPPC, rswm_q,
                  labels=as.character(hunan$County), 
                  xlab="GDPPC 2012", 
                  ylab="Spatially Lag GDPPC 2012")                    


```

### 3.7.2 Rescaling scatterplot to centre
- R-code is really quite powerful for statistics
- use of `scale` for standardisation of values to "centre" the plot

```{r}
#| code-fold: true
#| code-summary: "show code"
hunan$Z.GDPPC <- scale(hunan$GDPPC) %>% 
  as.vector                  
nci2 <- moran.plot(hunan$Z.GDPPC, rswm_q,
                   labels=as.character(hunan$County),
                   xlab="z-GDPPC 2012", 
                   ylab="Spatially Lag z-GDPPC 2012")

```

### 3.7.3 Preparing LISA Cluster Map:
- creates a vector called `quadrant` of length same as `localMI` (i.e. 88 regions)
- creates spatially lagged GDPPC and centre by removing mean
- also centre local moran's I value around its mean
- set statistical threshold of `0.05`
- partition 4 quadrants from low-low to high-high
    - "5th quadrant" of non-statistically significant regions


```{r}
#| code-fold: true
#| code-summary: "show code"
quadrant <- vector(mode="numeric",length=nrow(localMI))
hunan$lag_GDPPC <- lag.listw(rswm_q, hunan$GDPPC)
DV <- hunan$lag_GDPPC - mean(hunan$lag_GDPPC)     
LM_I <- localMI[,1]   
signif <- 0.05       

quadrant[DV <0 & LM_I>0] <- 1
quadrant[DV >0 & LM_I<0] <- 2
quadrant[DV <0 & LM_I<0] <- 3  
quadrant[DV >0 & LM_I>0] <- 4    
quadrant[localMI[,5]>signif] <- 0
```


### 3.7.3 Now we plot the map  LISA Cluster Map:
-


```{r}
#| code-fold: true
#| code-summary: "show code"
gdppc <- qtm(hunan, "GDPPC")+
  tm_layout(main.title = "Map of GDPPC")

hunan.localMI$quadrant <- quadrant
colors <- c("#ffffff", "#2c7bb6", "#abd9e9", "#fdae61", "#d7191c")
clusters <- c("insignificant", "low-low", "low-high", "high-low", "high-high")

LISAmap <- tm_shape(hunan.localMI) +
  tm_fill(col = "quadrant", 
          style = "cat", 
          palette = colors[c(sort(unique(quadrant)))+1], 
          labels = clusters[c(sort(unique(quadrant)))+1],
          popup.vars = c("")) +
  tm_view(set.zoom.limits = c(11,17)) +
  tm_borders(alpha=0.5)  +
  tm_layout(main.title = "LISA map by Quadrant")

tmap_arrange(gdppc, LISAmap, local_moran_stats, 
             local_moran_p, 
             asp=2, ncol=2)
```
## 3.8 HotSpot & ColdSPot Area Analysis
- `Hot Spot` refers to region with value higher than surrounding; similarly `Cold Spot` for lower

### 3.8.1 Getis and Ord’s Gi*-Statistics
- ultimate output `wm62_lw` is a weight matrix, using 62km as neighbour threshold, as a list of spatial weights
    - to find centroid, use Section 1.5.1 
    - to find cut-off distance, use Section 1.6.1
    - to computed fixed-distance weight, use Section 1.6.2

```{r}
#| code-fold: true
#| code-summary: "show code"
longitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])
latitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])
coords <- cbind(longitude, latitude)

k1 <- knn2nb(knearneigh(coords))
k1dists <- unlist(nbdists(k1, coords, longlat = TRUE))
summary(k1dists)

wm_d62 <- dnearneigh(coords, 0, 62, longlat = TRUE)
wm62_lw <- nb2listw(wm_d62, style = 'B')
summary(wm62_lw)

```


### 3.8.3 Computing adaptive distance weight matrix
- use `knn` with neighbours=8 (max) to enforce "smoothing of neighbour relationship"
    - note below, all 88 regions are "least connected" and "most connected"
- use `nb2listw` to convert `nb` object to list of spatial weights
    - note binary style i.e.

```{r}
#| code-fold: true
#| code-summary: "show code"

knn <- knn2nb(knearneigh(coords, k=8))
knn_lw <- nb2listw(knn, style = 'B')
summary(knn_lw)

```
## 3.9 Computing Gi* statistics
### 3.9.1 Computing Gi* statistics with Fixed Distance
- Using `wm62_lw` from above, creating fixed distance to calculate Z-score for Getis-Ord's Gi*-statistics
    - Z-score, higher value == greater intensity of clustering
    - (+) high clusters, (-) low clusters
- cbind back to create `hunan.gi` SpatialPolygonDataFrame
```{r}
#| code-fold: true
#| code-summary: "show code"
                       
fips <- order(hunan$County)
gi.fixed <- localG(hunan$GDPPC, wm62_lw)
hunan.gi <- cbind(hunan, as.matrix(gi.fixed)) %>%
  rename(gstat_fixed = as.matrix.gi.fixed.)

max_row <- hunan.gi[which.max(hunan.gi$gstat_fixed), ]
print(paste0("The region of deepest blue is: ", max_row$County))

head(hunan.gi, 5)

```
- draw map:
    - from above, darkest red Local Gi region is Wangcheng
```{r}
#| code-fold: true
#| code-summary: "show code"
                       
gdppc <- qtm(hunan, "GDPPC")  +
  tm_layout(main.title = "GDPPC", main.title.position ="right")

Gimap <-tm_shape(hunan.gi) +
  tm_fill(col = "gstat_fixed", 
          style = "pretty",
          palette="-RdBu",
          title = "local Gi*") +
  tm_borders(alpha = 0.5)  +
  tm_layout(main.title = "Local Gi*, fixed dist", main.title.position ="right")

tmap_arrange(gdppc, Gimap, asp=1, ncol=2)

```
::: callout-note
## **Quiz**: What statistical conclusion can you draw from the output above?

-  `Wangcheng` shows slightly higher Gi* value than `Changsha`, though both were identified earlier
- similar colour palette as quadrant mapping earlier; red regions are high-high, blue regions are low-low
    - overall, looks like there is some agreement of spatial auto-correlation when analysed like this

:::

### 3.9.2 Computing Gi statistics using Adaptive Distance 
- Using `knn_lw` from above with 8 fixed neighours for each region
    - I guess "adaptive distance" means "whatever distance needed to clock as neighbours"
```{r}
#| code-fold: true
#| code-summary: "show code"
                       
fips <- order(hunan$County)
gi.adaptive <- localG(hunan$GDPPC, knn_lw)
hunan.gi <- cbind(hunan, as.matrix(gi.adaptive)) %>%
  rename(gstat_adaptive = as.matrix.gi.adaptive.)

gdppc<- qtm(hunan, "GDPPC")  +
  tm_layout(main.title = "GDPPC", main.title.position ="right")
coolwarm <- colorRampPalette(c("blue", "white", "red"))(10)


Gimap_adaptive <- tm_shape(hunan.gi) + 
  tm_fill(col = "gstat_adaptive", 
          style = "pretty", 
          palette=coolwarm, 
          title = "local Gi* adaptive") + 
  tm_borders(alpha = 0.5)  +
  tm_layout(main.title = "Local Gi* adaptive dist", main.title.position ="right")

tmap_arrange(gdppc, 
             Gimap,
             Gimap_adaptive,
             asp=1, 
             ncol=3)

```

::: callout-note
## **Quiz**: What statistical conclusion can you draw from the output above?

- Using both fixed- and adaptive-distance neigbours generates similar results; values are largely in agreement
- knn=8 feels like it's not very logical, but maybe there's not too much difference 

:::