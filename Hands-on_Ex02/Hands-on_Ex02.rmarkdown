---
title: "Hands-on Exercise 2: Spatial Weights & Spatial Autocorrelation"
editor: visual
---


On this page, I address Hands-On Exercise for Chapter 02 - **Spatial Weights and Applications**

# 1. Spatial Weights & Applications

## 1.2 Import `Hunan` Shapefile datasets

### 1.1.1 Geospatial Data Sets

-   `/data/geospatial/Hunan.###`: This is a geospatial data set in ESRI shapefile format.

### 1.2.2 Aspatial Data Sets

-   `/data/aspatial/Hunan_2012.csv`: This csv file contains selected Hunan's local development indicators in 2012.

## 1.3 Import packages & files


```{r}
pacman::p_load(sf, spdep, tmap, tidyverse, knitr)
```

```{r}
hunan <- st_read(dsn = "data/geospatial", 
                 layer = "Hunan")
hunan2012 <- read_csv("data/aspatial/Hunan_2012.csv")
```


-   Left join to select only specific columns


```{r}
hunan <- left_join(hunan,hunan2012)%>%
  select(1:4, 7, 15)
```


## 1.4 Visualisation with qtm next to basemap


```{r}
#| code-fold: true
#| code-summary: "show code"
basemap <- tm_shape(hunan) +
  tm_polygons() +
  tm_text("NAME_3", size=0.5)

gdppc <- qtm(hunan, "GDPPC")
tmap_arrange(basemap, gdppc, asp=1, ncol=2)
```


## 1.5 Contiguity Spatial Weights

-   There are 2 types of contiguity, based on chess pieces
    -   `QUEEN` two regions are contiguous if they share a vertex;
    -   `ROOK` two regions are contiguous if they share an edge;
-   Literature suggests they are mostly similar, but `QUEEN` is more robust at capturing neighbouring/contiguity more consistently

#### 1.5.1 `QUEEN` Contiguity Neighbours


```{r}
#| code-fold: true
#| code-summary: "show code"
wm_q <- poly2nb(hunan, queen=TRUE)
summary(wm_q)
```


Identifying all neighbours of most connected region:


```{r}
#| code-fold: true
#| code-summary: "show code"
wm_q[[85]]
```


-   Name of region


```{r}
#| code-fold: true
#| code-summary: "show code"
cat("Most connected region:", hunan$County[85], "\n\n>> ID\t|  Name \t| GDPPC  \t|  Neighbours:")

for (value in wm_q[[85]]){
  cat("\n>> ", value, "\t|", hunan$County[value], "  \t|", hunan$GDPPC[value], "  \t|", wm_q[[value]])
  }
```


-   Print adjacency matrix (warning: long!)

::: {.callout-caution collapse="true"}
## Using `str()` to print adjacency weight matrix


```{r}
str(wm_q)
```

:::

#### 1.5.2 `ROOK` Contiguity Neighbours


```{r}
#| code-fold: true
#| code-summary: "show code"
wm_r <- poly2nb(hunan, queen=FALSE)
summary(wm_r)
```


-   Who's not there?


```{r}
setdiff(wm_q[[85]], wm_r[[85]])
```


### 1.5.3 Exploring Contiguity Weights

-   Get `latitude`, `longtiude` by
    -   `map_dbl` retrieving double-precision datatype via map function on `geometry` column of `hunan`
    -   use `st_centroid` to find centroid of each row
    -   indexing via \[\[1\]\], \[\[2\] for long,lat of centroid
    -   retrieving a vector of regions
-   `cbind` combines separate vectors back into single dataframe (`coords`)with two columns


```{r}
#| code-fold: true
#| code-summary: "show code"
longitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])
latitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])
coords <- cbind(longitude, latitude)
head(coords)
```


-   now plot Queen-contiguity based map using centroid vertices:


```{r}
#| code-fold: true
#| code-summary: "show code"
par(mfrow=c(1,3))
plot(hunan$geometry, border="lightgrey")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red", main="Queen Contiguity")
title("QUEEN Contiguity")
plot(hunan$geometry, border="lightgrey")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "blue", main="Rook Contiguity")
title("ROOK Contiguity")
plot(hunan$geometry, border="lightgrey")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red", main="Queen Contiguity")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "blue", main="Rook Contiguity")
title("Differences:")

```


------------------------------------------------------------------------

## 1.6 Distance-based neighbours

### 1.6.1 Identifying max inter-neighbour distance

-   `k1` created by parsing
    -   `knearneigh` returns matrix of k (default=1) nearest neighbours's index based on `coords`, apparently in `knn` object
    -   `knn2nb` converts k-nearest-neighbours to neighbours-list in `nb` class
-   `unlist` unbinds list structure of output into vector
    -   `nbdists` takes in `nb` neighbours list and returns euclidean distances between neighbours in same structure
-   all this searches the greatest neighbour distance (max 61.79 below) to ensure each region has at least one neighbour


```{r}
#| code-fold: true
#| code-summary: "show code"

# coords <- coordinates(hunan) #following previous steps
k1 <- knn2nb(knearneigh(coords))
k1dists <- unlist(nbdists(k1, coords, longlat = TRUE))
summary(k1dists)
```


### 1.6.2 Creating fixed distance weight matrix

-   `dnearneigh` returns list of vectors of regions satisfying distance criteria (eg within max neighbour distance)


```{r}
#| code-fold: true
#| code-summary: "show code"
wm_d62 <- dnearneigh(coords, 0, 62, longlat = TRUE)
cat("Printing details of distance weight matrix\n")
wm_d62

cat("\nInspecting first six rows of [wm_d62] obj \n")
cat(str(head(wm_d62, n=6)))

cat("\n^ Note how 6th row only has one neighbour, i.e. region 69")

```


::: callout-note
## **Quiz**: What is the meaning of "Average number of links: 3.681818" shown above?
- Each region has 3.68 links on average, i.e. (total number of links) / (total number of regions)
:::


-   Alternative structure (warning: long!)
    - this uses `table` to combine the column name from `hunan$Country` with
    - `card` apparently looks at the length of the neighbour list and prints 1 if yes, 0 if no (i.e. Anhua has `1` neighobur, Anren has `4`)

::: {.callout-caution collapse="true"}
## Using `str()` to print adjacency weight matrix


```{r}
table(hunan$County, card(wm_d62))
```

:::

### 1.6.2x Unfinished Disjoint subgraph plot 
- `n.comp.nb()` finds the number of disjoint connected subgraphs [[see source]](https://r-spatial.github.io/spdep/reference/compon.html)


```{r}
#| code-fold: true
#| code-summary: "show code"
n_comp <- n.comp.nb(wm_d62)
cat("Number of disjoint subgraphs:", n_comp$nc)
cat("\nTable of disjoint subgraphs by region:\n")
table(n_comp$comp.id)
cat("^ i.e. 88 regions all report 1 distjoint subgraph, i.e. no region is disjoint")

```


#### 1.6.2.1 Plotting fixed distance weight matrix

-   Plot background of `hunan$Geometry`
-   Plot points of centroids in `coords`, connected by black lines
-   Plot k=1-nearest-neighbours (i.e. show nearest neighbours as in `k1`) in red lines


```{r}
#| code-fold: true
#| code-summary: "show code"
plot(hunan$geometry, border="lightgrey")
plot(wm_d62, coords, add=TRUE)
plot(k1, coords, add=TRUE, col="red", length=0.08)
```


- Side-by-side comparison:

```{r}
#| code-fold: true
#| code-summary: "show code"
par(mfrow=c(1,2))
plot(hunan$geometry, border="lightgrey")
plot(k1, coords, add=TRUE, col="red", length=0.08, main="1st nearest neighbours")
title("1st Nearest Neighbours")
plot(hunan$geometry, border="lightgrey")
plot(wm_d62, coords, add=TRUE, pch = 19, cex = 0.6, main="Distance link")
title("Distance-Based Neighbours")
```


### 1.6.3 Exploring Contiguity Weights

-   Now allowing 6 nearest neighbours using knn 


```{r}
#| code-fold: true
#| code-summary: "show code"

knn6 <- knn2nb(knearneigh(coords, k=6))
cat("Printing details of knn neighbour matrix, k=6 \n")
knn6

cat("\nInspecting first six rows of [knn6] obj \n")
cat(str(head(knn6, n=6)))
cat("\n^ Note how every row now has 6 neighbours exactly.")
```


-   Here's what it looks like instead:


```{r}
#| code-fold: true
#| code-summary: "show code"
#| 
par(mfrow=c(1,2))
plot(hunan$geometry, border="lightgrey")
plot(k1, coords, pch = 19, cex = 0.6, add=TRUE, col="red", length=0.08, main="1st nearest neighbours")
title("1st Nearest Neighbours")

plot(hunan$geometry, border="lightgrey")
plot(knn6, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
title("6st Nearest Neighbours")

```




## 1.7 Using Inversed Distance to plot neighbour

-   Starting with `wm_q` for queen contiguity, `coords` for centroids    
    -   `nbdists` takes in `nb` neighbours list and returns euclidean distances between neighbours in same structure
    - `longlat` uses [Great Circle distances](https://en.wikipedia.org/wiki/Great-circle_distance) i.e. distance on a round earth instead of flat map
- `lapply` `function(x)` applies inverse (1/x) to all output distances

```{r}
#| code-fold: true
#| code-summary: "show code"
dist <- nbdists(wm_q, coords, longlat = TRUE)
ids <- lapply(dist, function(x) 1/(x))
cat("\nInspecting first five rows of [knn6] obj \n\n")
head(ids, 5)
```




### 1.7.1 Creating row-standardised weight matrix

- `style "W"` gives equal weight to each neighbour (e.g. 0.125 for 8 neighbours, below)


```{r}
#| code-fold: true
#| code-summary: "show code"
rswm_q <- nb2listw(wm_q, style="W", zero.policy = TRUE)
rswm_q

cat("\nInspecting weights for region 10, with 8 neighbours: \n")
rswm_q$weights[10]
```


- `style "B"` performs standardisation based on row distance


```{r}
#| code-fold: true
#| code-summary: "show code"
rswm_ids <- nb2listw(wm_q, glist=ids, style="B", zero.policy=TRUE)
rswm_ids

cat("\nPrinting summary stats for row-standardised weights matrix \n")
summary(unlist(rswm_ids$weights))

cat("\nInspecting weights for region 10, with 8 neighbours: \n")
rswm_ids$weights[10]
```





## 1.8 Making use of spatial weight matrix

### 1.8.1 spatial lag with row-standardized weights


::: callout-note
## **Quiz**: Can you see the meaning of Spatial lag with row-standardized weights now?
- Spatial lag describes how spatially-neighbouring regions affect each other
- 
:::


- `style "W"` gives equal weight to each neighbour (e.g. 0.125 for 8 neighbours, below)
    - `style "B"` gives equal weight to each neighbour (e.g. 1 for all 8 neighbours) 


```{r}
#| code-fold: true
#| code-summary: "show code"
rswm_q <- nb2listw(wm_q, style="W", zero.policy = TRUE)
rswm_q

cat("\nInspecting weights for region 10, with 8 neighbours: \n")
rswm_q$weights[10]
```


### 1.8.2 spatial lag as a sum of neighbouring values

- `style "W"` gives equal weight to each neighbour (e.g. 0.125 for 8 neighbours, below)
    - `style "B"` gives equal weight to each neighbour (e.g. 1 for all 8 neighbours) 


```{r}
#| code-fold: true
#| code-summary: "show code"
rswm_q <- nb2listw(wm_q, style="W", zero.policy = TRUE)
rswm_q

cat("\nInspecting weights for region 10, with 8 neighbours: \n")
rswm_q$weights[10]
```

### 1.8.3 spatial window average

- `style "W"` gives equal weight to each neighbour (e.g. 0.125 for 8 neighbours, below)
    - `style "B"` gives equal weight to each neighbour (e.g. 1 for all 8 neighbours) 


```{r}
#| code-fold: true
#| code-summary: "show code"
rswm_q <- nb2listw(wm_q, style="W", zero.policy = TRUE)
rswm_q

cat("\nInspecting weights for region 10, with 8 neighbours: \n")
rswm_q$weights[10]
```


### 1.8.4 spatial window sum

- `style "W"` gives equal weight to each neighbour (e.g. 0.125 for 8 neighbours, below)
    - `style "B"` gives equal weight to each neighbour (e.g. 1 for all 8 neighbours) 


```{r}
#| code-fold: true
#| code-summary: "show code"
rswm_q <- nb2listw(wm_q, style="W", zero.policy = TRUE)
rswm_q

cat("\nInspecting weights for region 10, with 8 neighbours: \n")
rswm_q$weights[10]
```

